# Redis
remote dictionary server  
Redis默认有16个数据库，用select切换  
支持多种数据结构

# Redis为什么单线程还这么快
- 误区1：高性能的服务器一定是多线程的？
- 误区2：多线程（CPU上下文会切换）一定比单线程效率高？  
CPU>内存>硬盘

核心：Redis是将所有的数据全部放在内存中，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文切换是会耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个cpu上，在内存情况下这就是最佳的方案

# Redis五大基本数据类型：
- String
- List
- Set
- Hash
- Zset
 
# Redis三种特殊的数据类型
- Geospatial地理位置
Redis3.2推出，定位，附近，距离计算
georadius db：table 经 纬 R km 

- Hyperloglog基数统计
位运算，统计key元素的基数数量，  
优点：占用内存固定，2^64不同元素的基数只需要12kb内存，比set节省很多空间，用于网站的计数统计

- Bitmap位图场景
使用bitmap（位）来记录每次的值

# 事务：
1. Redis的单条命令是保证原子性的，但是事务不保证原子性！
2. Redis事务没有隔离级别的概念，不存在幻读脏读不可重复读的情况。
    - 所有命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行。
3. Redis事务的本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行  
    - 一次性、顺序性、排他性
## 事务执行三步    
- 开启事务（multi）
- 命令入队（……）
- 执行事务（exec）


- 取消事务（discard）
- 监视：watch key（类似于MYSQL的version）
> 类似于乐观锁，获取version，更新的时候比较version。事务执行时如果值发生了改变则事务执行会失败  
> 解锁：unwatch

# Redis.config
== MODULES == 
```
loadmodule /path/to/my_module.so  
loadmodule /path/to/other_module.so
``` 
类似于import  

== NETWORK == 
```config 
bind 192.168.1.100 10.0.0.1 #绑定ip  
bind 127.0.0.1 ::1
protected-mode yes #保护模式
port 6379 #端口设置
```

== GENERAL == 
```
loglevel notice
logfile ""      #文件位置名
databases 16    #数据库的数量，默认是16
always-show-logo yes    #是否总是显示logo
```

=== SNAPSHOTTING ===
```
save 900 1
save 300 10
save 60 10000
```


# 持久化
## RDB
Redis Database
exp：在指定时间间隔内将内存中的数据集快照写入磁盘，即snapshot快照，在恢复时是将快照文件直接读入内存中。
- 默认方式
- 如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更加高效。
- RDB的缺点是最后一次持久化后的数据可能丢失。
- 触发RDB的三种方式：
    - 达到save规则中多少秒内进行多少次数据的修改操作
    - flushall
    - discard退出redis


## AOF
Append Only File  
exp：以日志的方式来记录每个操作，将Redis执行过程记录下来，只许追加文件不可以改写文件，redis启动之初会读取该文件重新构建数据，即redis重启时就根据日志文件的内容写指令从前到后执行一次以完成数据的恢复工作  
AOF保存的文件是append.aof

# 主从复制
Master-Slave  
主从复制，读写分离 
### 作用：
1. 数据冗余  
主从辅助实现了数据的热备份，是持久化之外的一种数据冗余方式
2. 故障修复  
主节点出现问题时可以由从节点提供服务，实现快速的故障修复，实际上是一种服务的冗余
3. 负载均衡  
可以由主节点提供写服务，从节点实现读服务，分担服务器负载，大大提高redis服务器的并发量
4. 高可用基石  
哨兵和集群可以实现的基础

一般来说，redis工程项目中为了防止宕机缓解服务器压力，往往通过一主多从的方式。
### 环境配置
只用配从库，不用配主库。默认情况下，所有每台redis服务器都是主节点。
```
info replication #查看当前库信息
```
vim redis.conf，修改port，pidfile，logfile（日志），dbfilename（备份）
### 哨兵模式
Redis提供了哨兵的命令，哨兵是一个独立的进程，它会独立运行，哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例
# 服务器的高可用问题
## 缓存穿透（查不到）：
- 解决方案：
    - 布隆过滤器：  
    - 缓存空对象：
## 缓存击穿（量太大，缓存过期）：
一个key非常热点，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就会穿破缓存，直接请求数据库，就像在一个屏幕上开了一个大洞
- 解决方案：
    - 设置热点数据永不过期
    - 加互斥锁
## 缓存雪崩
缓存雪崩：是指在某一个时间段，缓存集中过期失效，Redis宕机；
- 解决方案：
    - redis高可用  
    多设几台redis，一台崩掉了还有别的。其实就是搭建集群。异地多活
    - 限流降级
    缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量
    - 数据预热
    在正式部署前，我们先把可能的数据都预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的Key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
